package lib

import com.gu.media.Settings
import com.gu.media.aws.{DynamoAccess, AwsAccess}
import com.gu.scanamo
import com.typesafe.config.Config
import org.joda.time.DateTime
import org.joda.time.format.ISODateTimeFormat
import play.api.libs.json.{Reads, JsValue}
import akka.actor.Scheduler
import scala.annotation.tailrec
import scala.concurrent.duration._
import play.api.libs.json._
import com.amazonaws.services.sqs.model.{ReceiveMessageRequest, Message}
import com.amazonaws.services.sqs.AmazonSQSClient
import scala.concurrent.{Future, ExecutionContext}
import com.amazonaws.services.dynamodbv2.AmazonDynamoDBClient
import com.amazonaws.services.dynamodbv2.document.{DynamoDB}
import com.gu.scanamo._
import com.gu.media.pluto.AtomResponse

class UploaderMessageConsumer(plutoSenderConfig: PlutoSenderConfig) {


  def start(scheduler: Scheduler)(implicit ec: ExecutionContext): Unit = {
    scheduler.scheduleOnce(0.seconds)(processMessages())
  }

  lazy val client =
    new AmazonSQSClient(plutoSenderConfig.credsProvider)

  @tailrec
  private def processMessages(): Unit = {
    for (
      msg <- getMessages(waitTime = 20, maxMessages = 1)
    ) yield {
      extractSNSMessage(msg) match {
        case Some(message) => handleMessage(message)
        case None => //log an error: could not parse
      }
    }

    processMessages()

  }

  private def extractSNSMessage(sqsMessage: Message): Option[SNSMessage] =
    Json.fromJson[SNSMessage](Json.parse(sqsMessage.getBody)).asOpt

  private def getMessages(waitTime: Int, maxMessages: Int): Seq[Message] =
    client.receiveMessage(
      new ReceiveMessageRequest(plutoSenderConfig.queueUrl)
        .withWaitTimeSeconds(waitTime)
        .withMaxNumberOfMessages(maxMessages)
    ).getMessages.asScala.toList

  private def handleMessage(message: SNSMessage): Unit = {
    val mediaAtom: Option[AtomResponse] = Json.fromJson[AtomResponse](message.body).asOpt
    mediaAtom  match {
      case Some(atom @AtomResponse(_, _, _, Some(id))) => {
        //to other queue
      }
      case Some(atom @AtomResponse(_, _, _, None)) => {

        Scanamo.put(plutoSenderConfig.dynamoDB)(plutoSenderConfig.manualPlutoDynamo)(atom)
      }
      case None => {
        //error: could not extract atom from queue message
      }
    }
  }

  case class SNSMessage(
                         messageId: String,
                         timestamp: DateTime,
                         body: JsValue
                       )

  object SNSMessage {
    private def parseTimestamp(timestamp: String): DateTime =
      ISODateTimeFormat.dateTime.withZoneUTC.parseDateTime(timestamp)

    implicit def snsMessageReads: Reads[SNSMessage] =
      (
          (__ \ "MessageId").read[String] ~
            (__ \ "Timestamp").read[String].map(parseTimestamp) ~
          (__ \ "Message").read[String].map(Json.parse)
        )(SNSMessage(_, _, _))
  }
}

class PlutoSenderConfig(override val config: Config, val settings: Settings) extends AwsAccess with DynamoAccess {

  lazy val queueUrl = settings.getMandatoryString("uploaded.url")

}
